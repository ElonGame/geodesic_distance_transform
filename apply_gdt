import numpy as np
from IPython import embed

def geodesic_distance_2D(im,seeds,its=2):
    # geodesic2d raster scan
    # following paper from Toivanen et al
    
    #im is a 2D image with dimensions width,height
    #seeds is a 2D array with dimensions #seeds by 2 (xy coords)

    img = np.array(im,dtype=np.float32)
    width = img.shape[0]
    height = img.shape[1]
    distance = 1.0e10 * np.ones(img.shape,dtype=np.float32)
    seeds = np.array(seeds,dtype=np.int32)

    for s in range(seeds.shape[0]):
        distance[seeds[s,0],seeds[s,1]] = 0.0
    
    for it in range(its):
    
        #forward scan
        #kernel forward scan (paper Toivanen, table 3)
        kh_f = np.array([-1,-1,-1,0]) 
        kw_f = np.array([-1,0,1,-1])  
        
        #distance point p to point q (point in kernel)
        alpha_f = np.array([1.414, 1.0, 1.414, 1.0])

        #forward pass    
        for h in range(height):
            for w in range(width):
                #get distance and intensity value at point p
                p_dist = distance[w,h]
                p_val = img[w,h]
                
                #looping through kernel
                for i in range(4):
                    nh = h + kh_f[i]
                    nw = w + kw_f[i]
                    
                    #if selected pixel not in image continue
                    if nh < 0 or nh >= height or nw < 0 or nw >= width:
                        continue

                    #distance and intensity value at point q
                    q_dist = distance[nw,nh]
                    q_val = img[nw,nh]
                    
                    #from paper, dq = alpha*|G(p)-G(q)|
                    delta = alpha_f[i] * abs(p_val-q_val)
                    
                    #select minimal distance of calculated distance and current distance
                    #for point p
                    calc_dist = q_dist+delta   
                    if calc_dist < p_dist:
                        p_dist = calc_dist
                        
                #after going through kernel the selected distance is added to the distance map                        
                distance[w,h] = p_dist

        #backward scan
        #kernel backward scan (paper Toivanen, table 4)
        kh_b = np.array([0, 1, 1, 1]) 
        kw_b = np.array([1, -1, 0, 1])

        #distance point p to point q (point in kernel)
        alpha_b = np.array([1.0, 1.414, 1.0, 1.414])
        
        #loop through image in reverse order
        looph = np.arange(height)[::-1]
        loopw = np.arange(width)[::-1]

        for h in looph:
            for w in loopw:
                #get distance and intensity value at point p                
                p_dist = distance[w,h]
                p_val = img[w,h]
                
                #looping through kernel
                for i in range(4):
                    nh = h + kh_b[i]
                    nw = w + kw_b[i]
                    
                    #if selected pixel not in image continue
                    if nh < 0 or nh >= height or nw < 0 or nw >= width:
                        continue
                    
                    #distance and intensity value at point q                    
                    q_dist = distance[nw,nh]
                    q_val = img[nw,nh]
                    
                    #from paper, dq = alpha*|G(p)-G(q)|
                    delta = alpha_b[i] * abs(p_val-q_val)
                    
                    #select minimal distance of calculated distance and current distance
                    #for point p 
                    calc_dist = q_dist+delta
                    if calc_dist < p_dist:
                        p_dist = calc_dist
                        
                #after going through kernel the selected distance is added to the distance map                        
                distance[w,h] = p_dist
    
    return distance
